---
title: Production Actions Example
description: Real production actions with comprehensive Zod schemas
---

## Overview

This page demonstrates the production actions in `src/actions/actions.ts`. These are **real production code** that works in both test and production environments without any modifications. This is the core principle of `safemocker` - test your actual production code, not mocks of it.

### What This Example Shows

- **Real Production Code**: These actions are used in production and tested without modification
- **Complete CRUD Operations**: Full create, read, update, delete, and search functionality
- **Authentication Patterns**: Examples of required auth, optional auth, and authorization checks
- **Comprehensive Validation**: Complex Zod schemas with detailed error messages
- **Type Safety**: Full TypeScript inference with no type assertions needed

### Key Features

All actions include:

- ✅ **Comprehensive Zod Schemas**: Full validation with detailed error messages
- ✅ **Input/Output Validation**: Both input and output schemas for type safety
- ✅ **Authentication**: Proper auth middleware integration
- ✅ **Error Handling**: Complete error response handling
- ✅ **Type Safety**: 100% type-safe with `InferSafeActionFnResult`

## Available Actions

### createPost

Creates a new post with authentication required.

<DynamicCodeBlock
  lang="typescript"
  code={`import { z } from 'zod';
import { authedAction } from './safe-action';

export const createPost = authedAction
  .inputSchema(
    z.object({
      title: z.string().min(1, 'Title is required').max(200, 'Title must be less than 200 characters'),
      content: z.string().min(50, 'Content must be at least 50 characters'),
      slug: z.string().regex(/^[a-z0-9-]+$/, 'Slug must be lowercase alphanumeric with hyphens'),
      published: z.boolean().optional(),
      tags: z.array(z.string().min(1)).optional(),
    })
  )
  .outputSchema(
    z.object({
      id: z.string(),
      title: z.string(),
      content: z.string(),
      slug: z.string(),
      published: z.boolean(),
      authorId: z.string(),
      createdAt: z.string(),
      tags: z.array(z.string()),
    })
  )
  .metadata({ actionName: 'createPost', category: 'content' })
  .action(async ({ parsedInput, ctx }) => {
    const post = {
      id: \`post-\${Date.now()}\`,
      title: parsedInput.title,
      content: parsedInput.content,
      slug: parsedInput.slug,
      published: parsedInput.published ?? false,
      authorId: ctx.userId, // From auth middleware
      createdAt: new Date().toISOString(),
      tags: parsedInput.tags || [],
    };

    return post;
  });`}
/>

### getPost

Retrieves a post by ID with optional authentication.

<DynamicCodeBlock
  lang="typescript"
  code={`import { z } from 'zod';
import { optionalAuthAction } from './safe-action';

export const getPost = optionalAuthAction
  .inputSchema(
    z.object({
      postId: z.string().uuid('Invalid post ID'),
    })
  )
  .outputSchema(
    z.object({
      id: z.string(),
      title: z.string(),
      content: z.string(),
      slug: z.string(),
      published: z.boolean(),
      authorId: z.string(),
      isAuthor: z.boolean(),
      viewerId: z.string().optional(),
      createdAt: z.string(),
    })
  )
  .metadata({ actionName: 'getPost', category: 'content' })
  .action(async ({ parsedInput, ctx }) => {
    const post = {
      id: parsedInput.postId,
      title: 'Example Post',
      content: 'This is example content',
      slug: 'example-post',
      published: true,
      authorId: 'author-123',
      isAuthor: ctx.userId === 'author-123',
      viewerId: ctx.userId,
      createdAt: new Date().toISOString(),
    };

    return post;
  });`}
/>

### updatePost

Updates a post with authentication + authorization required.

<DynamicCodeBlock
  lang="typescript"
  code={`import { z } from 'zod';
import { authedAction } from './safe-action';

export const updatePost = authedAction
  .inputSchema(
    z.object({
      postId: z.string().uuid('Invalid post ID'),
      title: z.string().min(1).max(200).optional(),
      content: z.string().min(50).optional(),
      published: z.boolean().optional(),
    })
  )
  .outputSchema(
    z.object({
      id: z.string(),
      title: z.string(),
      content: z.string(),
      published: z.boolean(),
      updatedAt: z.string(),
    })
  )
  .metadata({ actionName: 'updatePost', category: 'content' })
  .action(async ({ parsedInput, ctx }) => {
    // Verify user owns the post (authorization check)
    const postAuthorId = 'author-123';
    if (ctx.userId !== postAuthorId) {
      throw new Error('Unauthorized: You can only update your own posts');
    }

    const updatedPost = {
      id: parsedInput.postId,
      title: parsedInput.title || 'Updated Title',
      content: parsedInput.content || 'Updated content with enough characters to pass validation requirements.',
      published: parsedInput.published ?? true,
      updatedAt: new Date().toISOString(),
    };

    return updatedPost;
  });`}
/>

### deletePost

Deletes a post with authentication + authorization required.

<DynamicCodeBlock
  lang="typescript"
  code={`import { z } from 'zod';
import { authedAction } from './safe-action';

export const deletePost = authedAction
  .inputSchema(
    z.object({
      postId: z.string().uuid('Invalid post ID'),
    })
  )
  .outputSchema(
    z.object({
      deleted: z.boolean(),
      postId: z.string(),
      deletedAt: z.string(),
    })
  )
  .metadata({ actionName: 'deletePost', category: 'content' })
  .action(async ({ parsedInput, ctx }) => {
    // Verify user owns the post
    const postAuthorId = 'author-123';
    if (ctx.userId !== postAuthorId) {
      throw new Error('Unauthorized: You can only delete your own posts');
    }

    return {
      deleted: true,
      postId: parsedInput.postId,
      deletedAt: new Date().toISOString(),
    };
  });`}
/>

### searchPosts

Searches posts by query with rate limiting and optional authentication.

<DynamicCodeBlock
  lang="typescript"
  code={`import { z } from 'zod';
import { rateLimitedAction } from './safe-action';

export const searchPosts = rateLimitedAction
  .inputSchema(
    z.object({
      query: z.string().min(1, 'Search query is required').max(100, 'Query too long'),
      limit: z.number().int().min(1).max(50).optional(),
    })
  )
  .outputSchema(
    z.object({
      results: z.array(
        z.object({
          id: z.string(),
          title: z.string(),
          slug: z.string(),
          published: z.boolean(),
        })
      ),
      total: z.number(),
    })
  )
  .metadata({ actionName: 'searchPosts', category: 'content' })
  .action(async ({ parsedInput }) => {
    // Rate limiting is handled by rateLimitedAction middleware
    return {
      results: [
        {
          id: 'post-1',
          title: 'Search Result 1',
          slug: 'search-result-1',
          published: true,
        },
        {
          id: 'post-2',
          title: 'Search Result 2',
          slug: 'search-result-2',
          published: true,
        },
      ],
      total: 2,
    };
  });`}
/>

## Testing

All actions are fully tested in `src/actions/actions.test.ts` with:

- Success cases
- Validation error cases
- Server error cases
- Type safety verification

### Example Test

Here's how to test the `createPost` action:

<Tabs items={['Jest', 'Vitest']} groupId="test-framework" persist>
  <Tab value="Jest">
```typescript
import { describe, expect, it } from '@jest/globals';
import { createPost } from './actions';
import type { InferSafeActionFnResult } from 'next-safe-action';

describe('createPost', () => {
  it('should create post successfully', async () => {
    const result = await createPost({
      title: 'My Post',
      content: 'This is the content of my post with enough characters to pass validation.',
      slug: 'my-post',
    });

    type CreatePostResult = InferSafeActionFnResult<typeof createPost>;
    const typedResult: CreatePostResult = result;

    expect(typedResult.data).toBeDefined();
    expect(typedResult.data?.title).toBe('My Post');
    expect(typedResult.data?.authorId).toBe('test-user-id');
    expect(typedResult.fieldErrors).toBeUndefined();
    expect(typedResult.serverError).toBeUndefined();
  });

  it('should return validation errors for invalid input', async () => {
    const result = await createPost({
      title: '', // Invalid
      content: 'short', // Invalid
      slug: 'INVALID', // Invalid: uppercase
    });

    type CreatePostResult = InferSafeActionFnResult<typeof createPost>;
    const typedResult: CreatePostResult = result;

    expect(typedResult.fieldErrors).toBeDefined();
    expect(typedResult.fieldErrors?.title).toBeDefined();
    expect(typedResult.fieldErrors?.content).toBeDefined();
    expect(typedResult.fieldErrors?.slug).toBeDefined();
    expect(typedResult.data).toBeUndefined();
  });
});
```
  </Tab>
  <Tab value="Vitest">
```typescript
import { describe, expect, it } from 'vitest';
import { createPost } from './actions';
import type { InferSafeActionFnResult } from 'next-safe-action';

describe('createPost', () => {
  it('should create post successfully', async () => {
    const result = await createPost({
      title: 'My Post',
      content: 'This is the content of my post with enough characters to pass validation.',
      slug: 'my-post',
    });

    type CreatePostResult = InferSafeActionFnResult<typeof createPost>;
    const typedResult: CreatePostResult = result;

    expect(typedResult.data).toBeDefined();
    expect(typedResult.data?.title).toBe('My Post');
    expect(typedResult.data?.authorId).toBe('test-user-id');
    expect(typedResult.fieldErrors).toBeUndefined();
    expect(typedResult.serverError).toBeUndefined();
  });

  it('should return validation errors for invalid input', async () => {
    const result = await createPost({
      title: '', // Invalid
      content: 'short', // Invalid
      slug: 'INVALID', // Invalid: uppercase
    });

    type CreatePostResult = InferSafeActionFnResult<typeof createPost>;
    const typedResult: CreatePostResult = result;

    expect(typedResult.fieldErrors).toBeDefined();
    expect(typedResult.fieldErrors?.title).toBeDefined();
    expect(typedResult.fieldErrors?.content).toBeDefined();
    expect(typedResult.fieldErrors?.slug).toBeDefined();
    expect(typedResult.data).toBeUndefined();
  });
});
```
  </Tab>
</Tabs>

See the [Testing Guide](/docs/guides/testing) for more details.

