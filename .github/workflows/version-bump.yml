# Version Bump & Changelog Generation
# Automatically bumps version, generates changelog, and creates release tag when PR is merged
#
# **What it does:**
# 1. Analyzes commits since last tag to determine version bump type (using git-cliff)
# 2. Calculates new version using git-cliff --bumped-version
# 3. Generates versioned changelog entry using git-cliff --tag vX.Y.Z --latest --unreleased
# 4. Updates package.json with new version
# 5. Commits version + changelog changes
# 6. Creates and pushes tag (which triggers publish-release.yml workflow)
#
# **Triggers:**
# - PR merge to main (automatic)
# - Manual workflow_dispatch (with optional bump_type override)
name: Version Bump & Changelog

on:
  pull_request:
    types: [closed]
    branches: [main]
  workflow_dispatch:
    inputs:
      bump_type:
        description: 'Version bump type (major, minor, patch, or "auto" to detect from commits)'
        required: false
        default: 'auto'
        type: choice
        options:
          - auto
          - major
          - minor
          - patch

# Only run when PR is merged (not just closed) OR when manually triggered
jobs:
  version-bump:
    # Skip if PR was closed without merging (but allow workflow_dispatch)
    if: github.event_name == 'workflow_dispatch' || github.event.pull_request.merged == true

    runs-on: ubuntu-latest
    timeout-minutes: 10

    permissions:
      contents: write # Required to push commits and tags
      pull-requests: read # Required to read PR info

    steps:
      - name: Checkout repository
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4
        with:
          # CRITICAL: fetch-depth: 0 needed for git-cliff to access full commit history
          fetch-depth: 0
          # Always checkout main branch (both PR merges and workflow_dispatch should use main)
          # For PR merges: github.ref points to PR ref, but we want the merged state on main
          # For workflow_dispatch: use main branch
          ref: main
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup pnpm
        uses: pnpm/action-setup@41ff72655975bd51cab0327fa583b6e92b6d3061 # v4
        with:
          version: 10

      - name: Setup Node.js
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Get last tag (with comprehensive debugging)
        id: last_tag
        run: |
          set -e  # Exit on error

          echo "ðŸ” DEBUG: Fetching all tags..."
          # CRITICAL: Fetch ALL tags (not just depth=1) to ensure we find the correct base tag
          git fetch --tags --force || true

          echo "ðŸ” DEBUG: Listing all tags..."
          git tag -l "v*" | sort -V

          echo "ðŸ” DEBUG: Getting most recent version tag..."
          # Get the most recent tag matching v*.*.* pattern
          # Use --abbrev=0 to get full tag name, not abbreviated
          LAST_TAG=$(git describe --tags --match 'v*.*.*' --abbrev=0 2>/dev/null || echo "")

          if [ -z "$LAST_TAG" ]; then
            echo "âš ï¸ No previous tag found, starting from v0.0.0"
            echo "TAG=v0.0.0" >> $GITHUB_OUTPUT
            echo "HAS_PREVIOUS=false" >> $GITHUB_OUTPUT
          else
            echo "âœ… Last tag found: $LAST_TAG"
            echo "TAG=$LAST_TAG" >> $GITHUB_OUTPUT
            echo "HAS_PREVIOUS=true" >> $GITHUB_OUTPUT

            # Debug: Show commit hash of last tag
            TAG_HASH=$(git rev-parse "$LAST_TAG" 2>/dev/null || echo "unknown")
            echo "ðŸ” DEBUG: Last tag $LAST_TAG points to commit: $TAG_HASH"
          fi

      - name: Get commits since last tag (with comprehensive debugging)
        id: commits
        run: |
          set -e  # Exit on error

          LAST_TAG="${{ steps.last_tag.outputs.TAG }}"
          HAS_PREVIOUS="${{ steps.last_tag.outputs.HAS_PREVIOUS }}"

          echo "ðŸ” DEBUG: Last tag: $LAST_TAG"
          echo "ðŸ” DEBUG: Has previous tag: $HAS_PREVIOUS"
          echo "ðŸ” DEBUG: Current HEAD: $(git rev-parse HEAD)"
          echo "ðŸ” DEBUG: Current branch: $(git branch --show-current || echo 'detached')"

          if [ "$HAS_PREVIOUS" == "true" ]; then
            echo "ðŸ” DEBUG: Getting commits since $LAST_TAG..."
            # Get commits since last tag (excluding merge commits)
            COMMITS=$(git log "$LAST_TAG"..HEAD --pretty=format:"%h %s" --no-merges)

            # Also get commit count for verification
            COMMIT_COUNT=$(git rev-list --count "$LAST_TAG"..HEAD --no-merges 2>/dev/null || echo "0")

            echo "ðŸ” DEBUG: Found $COMMIT_COUNT commits since $LAST_TAG:"
            echo "$COMMITS" | head -10
            if [ "$COMMIT_COUNT" -gt 10 ]; then
              echo "... and $((COMMIT_COUNT - 10)) more commits"
            fi
          else
            echo "ðŸ” DEBUG: No previous tag, getting all commits..."
            # Get all commits (no previous tag)
            COMMITS=$(git log --pretty=format:"%h %s" --no-merges)
            COMMIT_COUNT=$(git rev-list --count HEAD --no-merges 2>/dev/null || echo "0")

            echo "ðŸ” DEBUG: Found $COMMIT_COUNT total commits:"
            echo "$COMMITS" | head -10
            if [ "$COMMIT_COUNT" -gt 10 ]; then
              echo "... and $((COMMIT_COUNT - 10)) more commits"
            fi
          fi

          # Extract just commit messages for processing (remove commit hash)
          COMMIT_MESSAGES=$(echo "$COMMITS" | sed 's/^[a-f0-9]* //')

          # Count commits (handle empty case)
          if [ -z "$COMMIT_MESSAGES" ]; then
            COMMIT_COUNT=0
          else
            COMMIT_COUNT=$(echo "$COMMIT_MESSAGES" | grep -c . || echo "0")
          fi

          echo "COMMIT_COUNT=$COMMIT_COUNT" >> $GITHUB_OUTPUT

          # Store commit messages (base64 encoded to handle special chars)
          echo "$COMMIT_MESSAGES" | base64 -w 0 > /tmp/commits.txt || echo "" | base64 -w 0 > /tmp/commits.txt
          echo "COMMITS_FILE=/tmp/commits.txt" >> $GITHUB_OUTPUT

          # Log summary
          echo "ðŸ“Š Summary: Found $COMMIT_COUNT commits since last tag ($LAST_TAG)"
          if [ "$COMMIT_COUNT" -eq 0 ]; then
            echo "âš ï¸ No commits found - skipping release"
            echo "SKIP_RELEASE=true" >> $GITHUB_OUTPUT
          else
            echo "âœ… Proceeding with release"
            echo "SKIP_RELEASE=false" >> $GITHUB_OUTPUT
          fi

      - name: Determine version bump type and calculate new version
        id: version_calc
        if: steps.commits.outputs.SKIP_RELEASE != 'true'
        env:
          # GITHUB_TOKEN enables git-cliff to access GitHub API for better commit metadata
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e  # Exit on error

          echo "ðŸ” DEBUG: Determining version bump type..."

          # Check if manual bump type was provided (workflow_dispatch with non-"auto" value)
          if [ "${{ github.event_name }}" == "workflow_dispatch" ] && [ "${{ github.event.inputs.bump_type }}" != "auto" ]; then
            # Use manual bump type from workflow_dispatch input
            BUMP_TYPE="${{ github.event.inputs.bump_type }}"
            echo "âœ… Using manual bump type: $BUMP_TYPE"
          else
            # Auto-detect bump type using git-cliff
            # git-cliff analyzes commits and determines the appropriate bump type
            echo "ðŸ” Auto-detecting bump type using git-cliff..."
            BUMP_TYPE="auto"
          fi

          # Get current version from package.json
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          echo "ðŸ“¦ Current version: $CURRENT_VERSION"

          # Calculate new version using git-cliff
          # If manual bump type provided, use --bump [type] --bumped-version
          # If auto, use --bumped-version (git-cliff auto-detects)
          echo "ðŸ” DEBUG: Running git-cliff to calculate new version..."
          if [ "$BUMP_TYPE" == "auto" ]; then
            # Auto-detect: git-cliff analyzes commits and determines bump type
            echo "ðŸ” Running: pnpm exec git-cliff --config cliff.toml --bumped-version"
            NEW_VERSION_TAG=$(pnpm exec git-cliff --config cliff.toml --bumped-version 2>&1 | tail -1)
          else
            # Manual: use specified bump type
            echo "ðŸ” Running: pnpm exec git-cliff --config cliff.toml --bump $BUMP_TYPE --bumped-version"
            NEW_VERSION_TAG=$(pnpm exec git-cliff --config cliff.toml --bump "$BUMP_TYPE" --bumped-version 2>&1 | tail -1)
          fi

          echo "ðŸ” DEBUG: git-cliff returned: '$NEW_VERSION_TAG'"

          # Remove 'v' prefix from version tag (e.g., "v0.1.1" -> "0.1.1")
          NEW_VERSION="${NEW_VERSION_TAG#v}"

          # Validate version matches semver pattern
          if ! echo "$NEW_VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "âŒ Error: git-cliff returned invalid version '$NEW_VERSION' (from tag '$NEW_VERSION_TAG')" >&2
            echo "ðŸ” DEBUG: Full git-cliff output:" >&2
            if [ "$BUMP_TYPE" == "auto" ]; then
              pnpm exec git-cliff --config cliff.toml --bumped-version 2>&1 >&2
            else
              pnpm exec git-cliff --config cliff.toml --bump "$BUMP_TYPE" --bumped-version 2>&1 >&2
            fi
            exit 1
          fi

          # CRITICAL: Check if new version is the same as current version
          # This happens when there are no commits that warrant a version bump
          if [ "$NEW_VERSION" == "$CURRENT_VERSION" ]; then
            echo "âš ï¸ New version ($NEW_VERSION) is the same as current version ($CURRENT_VERSION)"
            echo "This means there are no commits that warrant a version bump."
            echo "Skipping release."
            echo "SKIP_RELEASE=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Determine the actual bump type by comparing versions
          IFS='.' read -r current_major current_minor current_patch <<< "$CURRENT_VERSION"
          IFS='.' read -r new_major new_minor new_patch <<< "$NEW_VERSION"

          if [ "$new_major" -gt "$current_major" ]; then
            DETECTED_BUMP_TYPE="major"
          elif [ "$new_minor" -gt "$current_minor" ]; then
            DETECTED_BUMP_TYPE="minor"
          elif [ "$new_patch" -gt "$current_patch" ]; then
            DETECTED_BUMP_TYPE="patch"
          else
            echo "âŒ Error: New version $NEW_VERSION is not greater than current version $CURRENT_VERSION" >&2
            exit 1
          fi

          # If manual bump type was provided, verify it matches detected type
          if [ "$BUMP_TYPE" != "auto" ] && [ "$BUMP_TYPE" != "$DETECTED_BUMP_TYPE" ]; then
            echo "âš ï¸ Warning: Manual bump type '$BUMP_TYPE' differs from git-cliff detected type '$DETECTED_BUMP_TYPE'"
            echo "Using manual bump type: $BUMP_TYPE"
            FINAL_BUMP_TYPE="$BUMP_TYPE"
          else
            FINAL_BUMP_TYPE="$DETECTED_BUMP_TYPE"
          fi

          echo "BUMP_TYPE=$FINAL_BUMP_TYPE" >> $GITHUB_OUTPUT
          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "âœ… Version bump: $CURRENT_VERSION â†’ $NEW_VERSION ($FINAL_BUMP_TYPE)"

      - name: Generate changelog
        id: changelog
        if: steps.commits.outputs.SKIP_RELEASE != 'true'
        env:
          # GITHUB_TOKEN enables automatic PR links, better commit metadata, and enhanced changelog entries
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e  # Exit on error

          NEW_VERSION="${{ steps.version_calc.outputs.NEW_VERSION }}"
          LAST_TAG="${{ steps.last_tag.outputs.TAG }}"

          echo "ðŸ” DEBUG: Generating changelog for version $NEW_VERSION"
          echo "ðŸ” DEBUG: Base tag: $LAST_TAG"

          # Verify GITHUB_TOKEN is set for GitHub API access
          if [ -z "$GITHUB_TOKEN" ]; then
            echo "âš ï¸ Warning: GITHUB_TOKEN is not set. GitHub integration features (PR links, usernames, contributors) will not be available."
            echo "ðŸ” DEBUG: This is expected if running locally without GITHUB_TOKEN"
          else
            echo "âœ… GITHUB_TOKEN is set - GitHub API integration enabled"
            echo "ðŸ” DEBUG: GitHub API will be used for:"
            echo "  - PR links in commit messages"
            echo "  - Contributor usernames"
            echo "  - PR titles and labels"
            echo "  - First-time contributor detection"
          fi

          # Check if changelog already has this version (from previous failed run)
          # Use -F for fixed string matching (brackets are literal, not regex)
          if grep -Fq "## [$NEW_VERSION]" CHANGELOG.md 2>/dev/null; then
            echo "âš ï¸ Changelog already contains version $NEW_VERSION, checking if it has content..."
            # If the version exists but has no content (only header), regenerate
            # Use -F for fixed string matching
            if grep -FA 10 "## [$NEW_VERSION]" CHANGELOG.md | grep -q "^###"; then
              echo "âœ… Changelog already has content for version $NEW_VERSION, skipping generation"
              echo "CHANGELOG_UPDATED=true" >> $GITHUB_OUTPUT
              exit 0
            else
              echo "âš ï¸ Changelog has version $NEW_VERSION but no content, regenerating..."
              # Remove the empty version section (from header to next version or end)
              awk -v version="$NEW_VERSION" '
                BEGIN { skip=0 }
                /^## \[/ {
                  if (index($0, "[" version "]") > 0) {
                    skip=1
                    next
                  }
                  if (skip) skip=0
                }
                !skip { print }
              ' CHANGELOG.md > CHANGELOG.md.tmp && mv CHANGELOG.md.tmp CHANGELOG.md
            fi
          fi

          # CRITICAL: Delete the new tag locally if it exists (from a previous failed run)
          # This ensures --latest uses LAST_TAG (not NEW_VERSION) as the starting point
          if git rev-parse "v$NEW_VERSION" >/dev/null 2>&1; then
            echo "âš ï¸ Tag v$NEW_VERSION already exists locally, deleting for changelog generation"
            git tag -d "v$NEW_VERSION" || true
          fi

          # Use --tag with --latest --unreleased to generate versioned changelog directly
          # This generates a changelog entry with [NEW_VERSION] instead of [Unreleased]
          # --output CHANGELOG.md explicitly writes to the file (required when using --tag)
          # --prepend is configured in cliff.toml, so it will prepend to existing CHANGELOG.md
          # --verbose provides debugging information
          # --topo-order ensures tags are sorted topologically (important for complex branching)
          echo "ðŸ” DEBUG: Running git-cliff to generate versioned changelog..."
          echo "ðŸ” Command: pnpm exec git-cliff --config cliff.toml --tag v$NEW_VERSION --latest --unreleased --output CHANGELOG.md --verbose --topo-order"

          # Generate versioned changelog (this prepends to CHANGELOG.md with [NEW_VERSION] header)
          # CRITICAL: --output is required to write to file when using --tag
          # GITHUB_TOKEN enables GitHub API access for PR links, usernames, and contributor data
          echo "ðŸ” DEBUG: Executing git-cliff with GitHub integration..."
          pnpm exec git-cliff --config cliff.toml --tag "v$NEW_VERSION" --latest --unreleased --output CHANGELOG.md --verbose --topo-order

          # Verify GitHub integration worked (check for PR links or usernames in changelog)
          if [ -n "$GITHUB_TOKEN" ]; then
            if grep -qE "\[#[0-9]+\]|@[a-zA-Z0-9-]+" CHANGELOG.md 2>/dev/null; then
              echo "âœ… GitHub integration successful - PR links and/or usernames found in changelog"
            else
              echo "âš ï¸ Warning: GitHub integration may not have worked - no PR links or usernames found"
              echo "ðŸ” DEBUG: This may be normal if commits don't have associated PRs"
            fi
          fi

          # Verify git-cliff generated content
          if [ ! -f CHANGELOG.md ]; then
            echo "âŒ git-cliff did not generate CHANGELOG.md"
            exit 1
          fi

          # Verify the version entry was created
          # Use -F for fixed string matching (brackets are literal, not regex)
          if ! grep -Fq "## [$NEW_VERSION]" CHANGELOG.md; then
            echo "âŒ Error: Changelog was generated but version $NEW_VERSION entry not found" >&2
            echo "ðŸ” DEBUG: First 20 lines of CHANGELOG.md:" >&2
            head -20 CHANGELOG.md >&2
            exit 1
          fi

          # Validate changelog has content (not just header)
          if ! grep -FA 5 "## [$NEW_VERSION]" CHANGELOG.md | grep -q "^###"; then
            echo "âš ï¸ Warning: Changelog section for version $NEW_VERSION appears empty (no subsections found)"
            echo "ðŸ” DEBUG: This may indicate no commits were categorized for this version"
          else
            echo "âœ… Changelog generated with content for version $NEW_VERSION"
          fi

          # Check if changelog has content (more than just the header)
          VERSION_LINES=$(awk -v version="$NEW_VERSION" '/^## \[/ { if (index($0, "[" version "]") > 0) { found=1; next } if (found && /^## \[/) exit; if (found) count++ } END { print count+0 }' CHANGELOG.md)
          echo "ðŸ” DEBUG: Version $NEW_VERSION section has $VERSION_LINES lines of content"

          # Verify changelog was updated
          if git diff --quiet CHANGELOG.md; then
            echo "âš ï¸ Changelog was not updated"
            echo "CHANGELOG_UPDATED=false" >> $GITHUB_OUTPUT
          else
            echo "âœ… Changelog updated with version $NEW_VERSION"
            echo "CHANGELOG_UPDATED=true" >> $GITHUB_OUTPUT
          fi

      - name: Update package.json version
        id: new_version
        if: steps.commits.outputs.SKIP_RELEASE != 'true' && steps.changelog.outputs.CHANGELOG_UPDATED == 'true'
        run: |
          set -e  # Exit on error

          # Update package.json with the version calculated by git-cliff
          NEW_VERSION="${{ steps.version_calc.outputs.NEW_VERSION }}"

          echo "ðŸ” DEBUG: Updating package.json version to $NEW_VERSION"

          # Use node to update package.json (preserves formatting)
          node -e "
            const fs = require('fs');
            const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
            pkg.version = '$NEW_VERSION';
            fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\n');
          "

          # Verify version was updated correctly
          ACTUAL_VERSION=$(node -p "require('./package.json').version")
          if [ "$ACTUAL_VERSION" != "$NEW_VERSION" ]; then
            echo "âŒ Error: Failed to update package.json version. Expected $NEW_VERSION but got $ACTUAL_VERSION" >&2
            exit 1
          fi

          # Validate version matches semver pattern
          if ! echo "$NEW_VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "âŒ Error: version '$NEW_VERSION' doesn't match semver pattern" >&2
            exit 1
          fi

          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "âœ… package.json version updated to: $NEW_VERSION"

      - name: Configure git
        if: steps.commits.outputs.SKIP_RELEASE != 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Commit version and changelog, then create and push tag
        if: steps.commits.outputs.SKIP_RELEASE != 'true' && steps.changelog.outputs.CHANGELOG_UPDATED == 'true'
        run: |
          set -e  # Exit on error

          NEW_VERSION="${{ steps.new_version.outputs.NEW_VERSION }}"

          echo "ðŸ” DEBUG: Committing version and changelog changes..."

          # Stage and commit version changes
          git add package.json CHANGELOG.md
          git commit -m "chore: bump version to $NEW_VERSION"

          echo "ðŸ” DEBUG: Pushing commit to main..."
          # Push commit first (ensures commit is on remote before tag)
          # Use regular push (not force) since we're pushing to main after merge
          if ! git push origin main; then
            echo "âŒ Error: Git push to main failed" >&2
            echo "ðŸ” DEBUG: This may indicate a conflict or permission issue" >&2
            exit 1
          fi

          echo "ðŸ” DEBUG: Verifying commit push succeeded..."
          # Verify commit push succeeded
          git fetch origin main
          LOCAL_HEAD=$(git rev-parse HEAD)
          REMOTE_HEAD=$(git rev-parse origin/main)
          if [ "$LOCAL_HEAD" != "$REMOTE_HEAD" ]; then
            echo "âŒ Error: Git push failed - local HEAD ($LOCAL_HEAD) does not match origin/main ($REMOTE_HEAD)" >&2
            echo "ðŸ” DEBUG: This indicates the push did not succeed" >&2
            exit 1
          fi
          echo "âœ… Commit push verified: local and remote are in sync"

          echo "ðŸ” DEBUG: Creating tag v$NEW_VERSION..."
          # Extract changelog summary for tag message (first 3 commit messages or first 200 chars)
          CHANGELOG_SUMMARY=$(grep -A 50 "## \[$NEW_VERSION\]" CHANGELOG.md 2>/dev/null | grep "^- " | head -3 | sed 's/^- //' | tr '\n' '; ' | cut -c1-200 || echo "")

          # Build tag message with version and summary
          # Use a temporary file to handle multi-line tag messages safely
          TAG_MSG_FILE=$(mktemp)
          echo "Release v$NEW_VERSION" > "$TAG_MSG_FILE"
          if [ -n "$CHANGELOG_SUMMARY" ]; then
            echo "" >> "$TAG_MSG_FILE"
            echo "$CHANGELOG_SUMMARY" >> "$TAG_MSG_FILE"
          fi

          # Create and push tag separately (ensures tag push event triggers publish-release.yml workflow)
          git tag -a "v$NEW_VERSION" -F "$TAG_MSG_FILE"
          rm -f "$TAG_MSG_FILE"

          echo "ðŸ” DEBUG: Pushing tag v$NEW_VERSION..."
          git push origin "v$NEW_VERSION"

          echo "âœ… Tag v$NEW_VERSION pushed successfully"

      - name: Summary
        if: always()
        run: |
          if [ "${{ steps.commits.outputs.SKIP_RELEASE }}" == "true" ]; then
            echo "## â­ï¸ Release Skipped" >> $GITHUB_STEP_SUMMARY
            echo "No commits found since last tag. Release skipped." >> $GITHUB_STEP_SUMMARY
          else
            echo "## âœ… Version Bump Complete" >> $GITHUB_STEP_SUMMARY
            echo "- **Version:** ${{ steps.new_version.outputs.NEW_VERSION }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Bump Type:** ${{ steps.version_calc.outputs.BUMP_TYPE }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Commits:** ${{ steps.commits.outputs.COMMIT_COUNT }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Tag:** v${{ steps.new_version.outputs.NEW_VERSION }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Changelog:** ${{ steps.changelog.outputs.CHANGELOG_UPDATED }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Next:** The tag push will automatically trigger the 'Publish Release' workflow." >> $GITHUB_STEP_SUMMARY
          fi

